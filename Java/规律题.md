## 规律题

### Lc31.下一个排列

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。
必须 原地 修改，只允许使用额外常数空间。

示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]

链接：https://leetcode-cn.com/problems/next-permutation

```java
//从后向前找到后一个字母大于第一个字母的位置，将其交换。然后将该位置之后的数降序排列。因为从后向前扫描的，所以后面的肯定是升序序列，即将其交换即可。如果没有找到后一个数小于前一个数的，根据题意则全部逆序。
class Solution {
    public void nextPermutation(int[] nums) {
        for(int i = nums.length - 1; i > 0; i--){
            if(nums[i-1] < nums[i]){
                for(int j = nums.length - 1; j >= i; j--){
                    if(nums[j] > nums[i-1]){
                        swap(nums,j,i-1);
                        //Arrays.sort(nums, i, nums.length);
                        reverse(nums, i);          
                        return;
                    }
                }
            }
        }
        //Arrays.sort(nums, 0, nums.length);
        reverse(nums, 0);
    }
    public void reverse(int[] nums, int index){
        int left = index;
        int right = nums.length-1;
        while(left < right){
            swap(nums, left, right);
            left++;
            right--;
        }
    }
    public void swap(int[] nums,int x, int y){
        int tmp = nums[x];
        nums[x] = nums[y];
        nums[y] = tmp;
    }
}
```

Lc_48.旋转矩阵

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

示例 2：
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]


链接：https://leetcode-cn.com/problems/rotate-image

```java
//以一行为基础，改变四周，逐步向内收敛
class Solution {
    public void rotate(int[][] matrix) {
        int length = matrix.length;
        for(int i = 0; i < length/2; i++){
            for(int j=i; j < length-1-i; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[length-1-j][i];
                matrix[length-1-j][i] = matrix[length-1-i][length-1-j];
                matrix[length-1-i][length-1-j] = matrix[j][length-1-i];
                matrix[j][length-1-i] = tmp;
            }
        }
    }
}
```

### [Lc_121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

```java
//思想：由当相邻两个数是递增的，相减得到一个值，记录该时最小和最大的标记，由于一直往后判断，所以最大值可一直更新
class Solution {
    public int maxProfit(int[] prices) {
        int length = prices.length;
        int min = Integer.MAX_VALUE;
        int max = -1;
        int ans = 0;
        for(int i = 0; i < length-1; i++){
            if(prices[i] < prices[i+1]){
                min = Math.min(min, prices[i]);
                //max = Math.max(max, prices[i+1]);错误的，因为:[2,1,2,0,1]这种情况
                max = prices[i+1];
                ans = Math.max(ans, max-min);
            }
        }
        return ans;
    }
}
```

### [Lc_128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Arrays.sort(nums);
        if(nums.length == 0){
            return 0;
        }
        int ans = 1;
        for(int i = 0; i < nums.length-1; i++){
            
            int tmp = 1;
            while(i+1 < nums.length && ((nums[i+1] == nums[i] + 1) || (nums[i+1] == nums[i]))){//或的情况是以防等值情况0，1，1，2，3            
                if(nums[i+1] == nums[i] + 1){
                    tmp++;
                }
                i++;
            }
            
            ans = Math.max(tmp , ans);
        }
        return ans;
    }
}
```

#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均**出现两次**。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

```java
/*
既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：
一个数和 0 做 XOR 运算等于本身：a⊕0 = a
一个数和其本身做 XOR 运算等于 0：a⊕a = 0
XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b
*/
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int tmp: nums){
            ans ^= tmp;
        }
        return ans;
    }
}
```

### [Lc_169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊n/2⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

**提示：**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

```java
/*
nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4

投票法正确思路：不妨假设整个数组的众数记做a，则最初的数组中a的数量大于其余所有数。当采用count计数的时候有两种情况：

1）假设candidate等于a，则当count从1变为0的过程，此区间内a的数量等于其余数的数量，因此以count=0为分界线，数组右端部分的众数仍然为a

2）假设candidate不等于a，则当count从1变为0的过程， 此区间内a的数量小于等于其余数的数量，因此以count=0为分界线，数组右端部分的众数仍然为a

因此，以count=0可以将整个原始数组分为若干部分，count=0右端部分的数组中的众数永远是a，最终必然会筛选出a
*/
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            if(count == 0){
                candidate = nums[i];
            }
            if(nums[i] == candidate){
                count++;
            }else{
                count--;
            }
        }
        return candidate;
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return(nums.length/2);//排完序可以直接返回中间的值
    }
```

### [Lc_238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请**不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内

**进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

```java
//根据0的个数判断
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int f = 0;
        int sum = 1;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                f++;
                continue;
            }
            sum *= nums[i];
        }
        for(int i = 0; i < nums.length; i++){
            if(f > 1){//如果零的个数大于1个，则所有的都为零
                nums[i] = 0;
            }else if(f == 1){//只有一个0时，除零本身是别的乘积，其他全完零
                nums[i] = nums[i] == 0?sum:0;
            }else{
                nums[i] = sum/nums[i];
            }                           
        }
        return nums;
    }
}
```

### [Lc_240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例 1：**

![img](image/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![img](image/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-109 <= matrix[i][j] <= 109`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-109 <= target <= 109`

```java
//从矩阵的右上角开始排除，如果目标节点大，则向左走缩小，如果小则向下走变大
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int x = 0;
        int y = n-1;
        while(x < m && y >= 0){
            if(matrix[x][y] == target){
                return true;
            }else if(matrix[x][y] > target){
                y--;
            }else{
                x++;
            }
        }
        return false;
    }
}
```

```java
//从左下角开始
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int x = m-1;
        int y = 0;
        while(x >= 0 && y < n){
            if(matrix[x][y] == target){
                return true;
            }else if(matrix[x][y] > target){
                x--;
            }else{
                y++;
            }
        }
        return false;
    }
}
```

```java
//题目要求不能使用除法
//采用两个数组分别记录，每个下标对应的值是数组下标前的乘积
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] left = new int[length];
        int[] right = new int[length];
        left[0] = 1;
        right[length-1] = 1;
        for(int i = 1; i < length; i++){
            left[i] = left[i-1] * nums[i-1];
        }
        for(int i = length - 2; i >=0;i--){
            right[i] = right[i+1] * nums[i+1];
        }
        for(int i = 0; i < length; i++){
            nums[i] = left[i] * right[i];
        }
        return nums;
    }
}
```

```java
//在上面的基础上进行优化，利用一个结果返回数组，
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] ans = new int[length];
        ans[0] = 1;
        for(int i = 1; i < length; i++){
            ans[i] = ans[i-1] * nums[i-1];
        }
        int right = 1;
        for(int i = length - 1; i >=0;i--){
            ans[i] = ans[i] * right;
            right = right * nums[i];   
        }
        return ans;
    }
}
```

### [Lc_406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

**提示：**

- `1 <= people.length <= 2000`
- `0 <= hi <= 106`
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建

```java
//按身高从小到大排序，然后根据前面有多少比其高的人进行插入，因为当身高相同时，其中按照比起高的人数降序排列，所以在判断时，在考虑没有插入时也应考虑比其大于或等于时，其num(比其高的人)要减1
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(o1,o2)->{
            if(o1[0] != o2[0]){
                return o1[0] - o2[0];
            }else{
                return o1[1] - o2[1];
            }
        });
        int length = people.length;
        int[][] ans = new int[length][];//不能声明出维的长度，不然无法判空作为条件
        for(int i = 0; i < length; i++){
            int num = people[i][1];
            while(num >= 0){
                for(int j = 0; j < length; j++){
                    //因为当身高相同时，其高于其身高依旧按升序，也就是说当[5][0]已经插入，插入[5][1]时，不能只考虑空才减
                    if(ans[j] == null || ans[j][0] >= people[i][0]){
                        if(num == 0){
                            ans[j] = new int[]{people[i][0], people[i][1]};
                            num--;
                            break;
                        }
                        num--;
                    }
                }
            }
        }
        return ans;
    }
}
```

```java
//当身高相同时，按照降序排列，对其同样身高的，将[5][1]提前排在[5][0]之后，即减少一个判断条件。同时做优化
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(o1,o2)->{
            if(o1[0] != o2[0]){
                return o1[0] - o2[0];
            }else{
                return o2[1] - o1[1];
            }
        });
        int length = people.length;
        int[][] ans = new int[length][];
        for(int i = 0; i < length; i++){
            int num = people[i][1];    //不需要while
            for(int j = 0; j < length; j++){
                if(ans[j] == null){
                    if(num == 0){//减少一个判断条件
                        ans[j] = new int[]{people[i][0], people[i][1]};
                        break;
                    }
                    num--;
                }
             }    
        }
        return ans;
    }
}
```

### [Lc_461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

**示例 1：**

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

**示例 2：**

```
输入：x = 3, y = 1
输出：1
```

**提示：**

- `0 <= x, y <= 231 - 1`

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int ans = 0;
        while(x != 0 || y != 0){
            if(x%2 != y%2){
                ans++;
            }
            x /= 2;
            y /= 2;
        }
        return ans;
    }
}
```

```java
//异或，位移
class Solution {
    public int hammingDistance(int x, int y) {
        int ans = 0;
        int s = x^y;
        while(s != 0){
            ans += s&1;
            s >>= 1;
        }
        return ans;
    }
}
```

![fig3](image/3.png)

```java
//异或之后得到的，每次与减一的值进行相与，即可排除结尾的零
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;
            ret++;
        }
        return ret;
    }
}
```

### [Lc_581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

**示例 1：**

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：0
```

**示例 3：**

```
输入：nums = [1]
输出：0
```

**提示：**

- `1 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`

```java
//本题只需要查找最左右位置是否符合
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        int[] tmp = new int[len];
        for(int i = 0; i < len; i++){
            tmp[i] = nums[i];
        }
        Arrays.sort(tmp);
        int left = 0;
        while(left < len && nums[left] == tmp[left]){
            left++;
        }
        int right = len-1;
        while(right>=0 && nums[right] == tmp[right]){
            right--;
        }
        if(left==len && right == -1){
            return 0;
        }else{
            return right-left+1;
        }
    }
}
```

```java
//一次遍历，确定右边界，从左到右，记录前面大的数，如果有比前小的数，说明右边界在此，不断找。
//左边界，从右向左，记录最小的，当遇到比他大的，说明左边界在此
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int left = -1;
        int right = -1;
        for(int i = 0; i < len; i++){
            if(max > nums[i]){
                right = i;
            }else{
                max = nums[i];
            }

            if(min < nums[len-i-1]){
                left = len-i-1;
            }else{
                min = nums[len-i-1];
            }
        }
        return right==-1?0:right-left+1;
    }
}
```

#### [Lc_621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 **相同种类** 的任务之间必须有长度为整数 `n` 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 **最短时间** 。

**示例 1：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```

**示例 2：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
```

**示例 3：**

```
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
```

**提示：**

- `1 <= task.length <= 104`
- `tasks[i]` 是大写英文字母
- `n` 的取值范围为 `[0, 100]`

![image.png](image/893c01db5923889a865d7a4fe71de22b9519fc5a673473196ab58f26c1073ed2-image.png)

```java
//(maxLen - 1)代表除了最后一行的行数，(n + 1)代表的为列数，因为最后一行不存在间隔，所以最后一行的容量要单独考虑。如果(maxLen - 1)被填满，则ans为tasks.length，因为不存在间隙了。当没被填满，如上图，第三列的任务不存在，只有ab时，需要考虑最后一行maxlen的数量
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] tmp = new int[26];
        int maxLen = 0;
        for(int i = 0; i < tasks.length; i++){
            tmp[tasks[i] - 'A']++;
            maxLen = Math.max(maxLen,tmp[tasks[i] - 'A']);
        }
        int maxCount = 0;
        for(int i = 0; i < 26; i++){
            if(tmp[i] == maxLen){
                maxCount++;
            }
        }
        return Math.max(tasks.length, (maxLen-1)*(n+1) + maxCount);
    }
}
```

### [Lc_36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1：**

![img](image/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`

```java
//分别对每一列、行和每个9宫格进行从1-9统计，如有数大于1则表明不是有效的
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] row = new int[9][9];
        int[][] col = new int[9][9];
        int[][][] m = new int[3][3][9];
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                if(board[i][j] != '.'){
                    int tmp = board[i][j] - '1';
                    row[i][tmp]++;
                    col[j][tmp]++;
                    m[i/3][j/3][tmp]++;
                    if(row[i][tmp] > 1 || col[j][tmp] > 1 || m[i/3][j/3][tmp] > 1){
                        return false;
                    }
                } 
            }
        }
        return true;
    }
}
```

### [Lc_54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![img](image/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](image/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

```java
//先行走到底，在竖走到底，在横回来，再上去
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int y = Math.min(m,n);//根据小的去走
        int x = (y%2 == 1)? y/2+1 : y/2;
        List<Integer> ans = new ArrayList<>();
        for(int i = 0; i < x; i++){
            for(int j = i; j < n-i; j++){
                ans.add(matrix[i][j]);
            }
            for(int j = i+1; j <= m-i-1; j++){
                ans.add(matrix[j][n-i-1]);
            }
            //防止剩一行多加
            for(int j = n-i-2; j >= i && m-i-1 != i; j--){
                ans.add(matrix[m-i-1][j]);
            }
            //防止最后剩一列多加
            for(int j = m - i - 2; j > i && i != n-1-i; j--){
                ans.add(matrix[j][i]);
            }
        }
        return ans;
    }
}
```

### [Lc_59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

![img](image/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] ans = new int[n][n];
        int index = 1;
        int m = (n%2 == 0) ? n/2 : (n/2 + 1);
        for(int i = 0; i < m; i++){
            for(int j = i; j <= n-1-i; j++){
                ans[i][j] = index;
                index++;
            }
            for(int j = i+1; j <= n-1-i; j++){
                ans[j][n-1-i] = index;
                index++;
            }
            for(int j = n-2-i; j >= i && j != n-1-i; j--){
                ans[n-1-i][j] = index;
                index++;
            }
            for(int j = n-i-2; j > i && i != n-1-i; j--){
                ans[j][i] = index;
                index++;
            }
        }
        return ans;
    }
}
```

### [Lc_57. 插入区间](https://leetcode.cn/problems/insert-interval/)

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

**示例 2：**

```
输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
```

**示例 3：**

```
输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
```

**示例 4：**

```
输入：intervals = [[1,5]], newInterval = [2,3]
输出：[[1,5]]
```

**示例 5：**

```
输入：intervals = [[1,5]], newInterval = [2,7]
输出：[[1,7]] 
```

**提示：**

- `0 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= intervals[i][0] <= intervals[i][1] <= 105`
- `intervals` 根据 `intervals[i][0]` 按 **升序** 排列
- `newInterval.length == 2`
- `0 <= newInterval[0] <= newInterval[1] <= 105`

```java
//因为只插入一个区间，所以
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> tmp = new ArrayList<>();
        int left = newInterval[0];
        int right = newInterval[1];
        boolean f = false;
        for(int[] interval : intervals){
            if(right < interval[0]){//无交集
                if(!f){//无交集，且没此区间
                    tmp.add(new int[]{left,right});
                    f = true;
                }
                tmp.add(interval);
            }else if(interval[1] < left){//无交集，比left小时
                tmp.add(interval);
            }else{//有交集的时候，
                left = Math.min(left, interval[0]);
                right = Math.max(right, interval[1]);
            }
        }
        if(!f){
            tmp.add(new int[]{left, right});
        }
        int[][] ans = new int[tmp.size()][2];
        for(int i = 0; i < tmp.size(); i++){
            int[] t = tmp.get(i);
            ans[i] = t;
        }
        return ans;
    }
}
```

### [Lc_89. 格雷编码](https://leetcode.cn/problems/gray-code/)

**n 位格雷码序列** 是一个由 `2n` 个整数组成的序列，其中：

- 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）
- 第一个整数是 `0`
- 一个整数在序列中出现 **不超过一次**
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。

 

**示例 1：**

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

**示例 2：**

```
输入：n = 1
输出：[0,1]
```

**提示：**

- `1 <= n <= 16`

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<>();
        ans.add(0);
        for(int i = 1; i <= n; i++){
            int m = ans.size();
            for(int j = m-1; j >= 0; j--){//每次在上一结果中前一位加1，也就是对前面的结果乘2加入到结果中
                ans.add(ans.get(j) | (1 << (i - 1)));
            } 
        }
        return ans;
    }
}
```

### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

难度简单835

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](image/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```

**提示:**

- `1 <= numRows <= 30`

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0; i < numRows; i++){
            List<Integer> tmp = new ArrayList<>();
            tmp.add(1);
            for(int j = 1; j < i; j++){
                tmp.add(ans.get(i-1).get(j-1) + ans.get(i-1).get(j));
            }
            if(i != 0){
                tmp.add(1);
            }
            ans.add(tmp);
        }
        return ans;
    }
}
```

### [119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/)

难度简单426

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](image/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: rowIndex = 3
输出: [1,3,3,1]
```

**示例 2:**

```
输入: rowIndex = 0
输出: [1]
```

**示例 3:**

```
输入: rowIndex = 1
输出: [1,1]
```

**提示:**

- `0 <= rowIndex <= 33`

**进阶：**

你可以优化你的算法到 `*O*(*rowIndex*)` 空间复杂度吗？

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0; i <= rowIndex; i++){
            List<Integer> tmp = new ArrayList<>();
            tmp.add(1);
            for(int j = 1; j < i; j++){
                tmp.add(ans.get(i-1).get(j-1) + ans.get(i-1).get(j));
            }
            if(i != 0){
                tmp.add(1);
            }
            ans.add(tmp);
        }
        return ans.get(rowIndex);
    }
}
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

难度中等1823

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

```java
class Solution {
    public int maxProfit(int[] prices) {
        // int ans = 0;
        // for(int i = 1; i < prices.length; i++){
        //     if(prices[i-1] < prices[i]){
        //         ans += prices[i] - prices[i-1];
        //     }
        // }
        // return ans;
        int n = prices.length;
        int dp0 = 0;//没持有股票的状态
        int dp1 = -prices[0];//持有股票的状态
        for (int i = 1; i < n; ++i) {
            int newDp0 = Math.max(dp0, dp1 + prices[i]);
            int newDp1 = Math.max(dp1, dp0 - prices[i]);
            dp0 = newDp0;
            dp1 = newDp1;
        }
        return dp0;
    }
}
```

### [134. 加油站](https://leetcode.cn/problems/gas-station/)

难度中等1030

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        // for(int i = 0; i < gas.length; i++){
        //     boolean f = false;
        //     int tmp = 0;
        //     for(int j = i; j < cost.length; j++){
        //         tmp += gas[j];
        //         tmp = tmp - cost[j];
        //         if(tmp < 0){
        //             f = true;
        //             break;
        //         }
        //     }
        //     if(!f){
        //         for(int j = 0; j < i; j++){
        //             tmp += gas[j];
        //             tmp = tmp - cost[j];
        //             if(tmp < 0){
        //                 break;
        //             }
        //         }
        //     }
        //     if(tmp >= 0)
        //     return i;
        // }
        // return -1;
        for(int i = 0; i < gas.length; i++){
            gas[i] = gas[i] - cost[i];
        }
        int t = 0;
        int max = Integer.MIN_VALUE;
        int ans = 0;
        for(int i = gas.length-1; i >= 0; i--){
            t += gas[i];
            if(t > max){
                max = t;
                ans = i;
            }
        }
        if(t < 0){
            return -1;
        }else{
            return ans;
        }
    }
}
```

### [135. 分发糖果](https://leetcode.cn/problems/candy/)

难度困难987

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两条件。 
```

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`

```java
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] tmp = new int[len];
        tmp[0] = 1;
        for(int i = 1; i < len; i++){
            if(ratings[i] > ratings[i-1]){
                tmp[i] = tmp[i-1] + 1;
            }else if(ratings[i] == ratings[i-1]){
                tmp[i] = 1;
            }else{
                int left = i-1;
                int right = i;
                while(right+1<len && ratings[right] > ratings[right+1]){
                    right++;
                }
                i = right;
                for(int j = right; j > left; j--){
                    tmp[j] = 1+right-j;
                }
                if(right-left+1 > tmp[left]){
                    tmp[left] = right-left + 1;
                }

            }
        }
        int ans = 0;
        for(int i = 0; i < len; i++){
            ans += tmp[i];
        }
        return ans;
    }
}
```

### [149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

难度困难436

给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

**示例 1：**

![img](image/plane1.jpg)

```
输入：points = [[1,1],[2,2],[3,3]]
输出：3
```

**示例 2：**

![img](image/plane2.jpg)

```
输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4
```

**提示：**

- `1 <= points.length <= 300`
- `points[i].length == 2`
- `-104 <= xi, yi <= 104`
- `points` 中的所有点 **互不相同**

```java
class Solution {
    public int maxPoints(int[][] ps) {
        int n = ps.length;
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int[] x = ps[i];
            for (int j = i + 1; j < n; j++) {
                int[] y = ps[j];
                int cnt = 2;
                for (int k = j + 1; k < n; k++) {
                    int[] p = ps[k];
                    int s1 = (y[1] - x[1]) * (p[0] - y[0]);
                    int s2 = (p[1] - y[1]) * (y[0] - x[0]);
                    if (s1 == s2) cnt++;
                }
                ans = Math.max(ans, cnt);
            }
        }
        return ans;
    }
}
```

### [166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

难度中等410

给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 **任意一个** 。

对于所有给定的输入，**保证** 答案字符串的长度小于 `104` 。

**示例 1：**

```
输入：numerator = 1, denominator = 2
输出："0.5"
```

**示例 2：**

```
输入：numerator = 2, denominator = 1
输出："2"
```

**示例 3：**

```
输入：numerator = 4, denominator = 333
输出："0.(012)"
```

**提示：**

- `-231 <= numerator, denominator <= 231 - 1`
- `denominator != 0`

![QQ图片20211003090709.jpg](image/1633223480-OLGSxy-file_1633223479713)

```java
//题解如上图
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long a = numerator;
        long b = denominator;
        
        if(a%b == 0){
            return String.valueOf(a/b);
        }

        StringBuilder sb = new StringBuilder();
        if(a*b < 0){
            sb.append("-");
        }
        a = Math.abs(a);
        b = Math.abs(b);
        sb.append(String.valueOf(a/b) + ".");

        a %= b;
        Map<Long,Integer> map = new HashMap<>();
        while(a != 0){
            map.put(a, sb.length());
            a *= 10;
            sb.append(String.valueOf(a/b));
            a %= b;
            if(map.containsKey(a)){
                int idx = map.get(a);
                return String.format("%s(%S)", sb.substring(0,idx), sb.substring(idx));
            }

        }
        return sb.toString();

    }
}
```

### [168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/)

难度简单556

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

**示例 1：**

```
输入：columnNumber = 1
输出："A"
```

**示例 2：**

```
输入：columnNumber = 28
输出："AB"
```

**示例 3：**

```
输入：columnNumber = 701
输出："ZY"
```

**示例 4：**

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```

**提示：**

- `1 <= columnNumber <= 231 - 1`

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder sb = new StringBuilder();
        while(columnNumber > 0){
            sb.append((char)('A' + (columnNumber%26==0?25:columnNumber%26 - 1)));
            if(columnNumber%26==0 && columnNumber/26 == 1){
                break;
            }
            columnNumber -= (columnNumber%26==0?26:columnNumber%26);
            columnNumber /= 26;
           
        }
        sb.reverse();
        return sb.toString();
    }
}//看做是每次取余，然后减去余数
```

```c++
// 这是一道从 1开始的的 26 进制转换题。

// 对于一般性的进制转换题目，只需要不断地对 columnNumbercolumnNumber 进行 % 运算取得最后一位，然后对 columnNumbercolumnNumber 进行 / 运算，将已经取得的位数去掉，直到 columnNumbercolumnNumber 为 0即可。

// 一般性的进制转换题目无须进行额外操作，是因为我们是在「每一位数值范围在 [0,x)的前提下进行「逢 x 进一」。

// 但本题需要我们将从 1开始，因此在执行「进制转换」操作前，我们需要先对 columnNumbercolumnNumber 执行减一操作，从而实现整体偏移。
// 和正常 0~25 的 26 进制相比，本质上就是每一位多加了 1。假设 A == 0，B == 1，那么 AB = 26 * 0 + 1 * 1，而现在 AB = 26 * (0 + 1) + 1 * (1 + 1)，所以只要在处理每一位的时候减 1，就可以按照正常的
class Solution {
public:
    string convertToTitle(int columnNumber) 
    {
        string s;
        int t=0;
        while(columnNumber!=0)
        { 
            t=(columnNumber-1)%26+1;
            s+=t-1+'A';
            columnNumber=(columnNumber-t)/26;
        }
        reverse(s.begin(),s.end());
        return s;
    }
};

```

### [171. Excel 表列序号](https://leetcode.cn/problems/excel-sheet-column-number/)

难度简单346

给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回 *该列名称对应的列序号* 。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

**示例 1:**

```
输入: columnTitle = "A"
输出: 1
```

**示例 2:**

```
输入: columnTitle = "AB"
输出: 28
```

**示例 3:**

```
输入: columnTitle = "ZY"
输出: 701
```

**提示：**

- `1 <= columnTitle.length <= 7`
- `columnTitle` 仅由大写英文组成
- `columnTitle` 在范围 `["A", "FXSHRXW"]` 内

```java
class Solution {
    public int titleToNumber(String columnTitle) {
        int len = columnTitle.length();
        int ans = 0;
        int p = 0;
        for(int i = len-1;i >= 0; i--){
            int tmp = (int)(columnTitle.charAt(i) - 'A' + 1);
            ans += tmp * Math.pow(26, p);
            p++;
        }
        return ans;
    }
}
```

### [172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)

难度中等719

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

**提示：**

- `0 <= n <= 104`

**进阶：**你可以设计并实现对数时间复杂度的算法来解决此问题吗？

```java
//在阶乘中，产生0的为10,5，但是10中也有5.5的个数即为0的后缀
class Solution {
    public int trailingZeroes(int n) {
        int ans = 0;
        while(n != 0){
            n /= 5;
            ans += n;
        }
        return ans;
    }
}
```

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

难度中等1612

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

```java
//翻转再翻转
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        k %= len;
        reverse(nums, 0, len-1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, len-1);
        
    }
    private void reverse(int[] nums, int start, int end){
        while(start < end){
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
```

### [204. 计数质数](https://leetcode.cn/problems/count-primes/)

难度中等946

给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。

**示例 1：**

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**示例 2：**

```
输入：n = 0
输出：0
```

**示例 3：**

```
输入：n = 1
输出：0
```

**提示：**

- `0 <= n <= 5 * 106`

```java
//埃塞法，如果n是质数，那么他的倍数一定不是质数
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        int ans = 0;
        for(int i = 2; i < n; i++){
            if(!isPrime[i]){
                ans++;
                if((long) i * i < n){
                    for(int j = i*i; j < n; j += i){//从i*i开始是因为前面的在处理过程中已经被处理过了
                        isPrime[j] = true;
                    }
                }
            }
        }
        return ans;
    }
}
```

### [137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

难度中等921

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

```java
//利用 int 类型固定为 32 位。使用一个长度为 32 的数组cnt[]记录下所有数值的每一位共出现了多少次 11，再对cnt[]数组的每一位进行 mod 3 操作，重新拼凑出只出现一次的数值。

class Solution {
    public int singleNumber(int[] nums) {
        int[] tmp = new int[32];
        for(int num : nums){
            for(int i = 0; i < 32; i++){
                if(((num >> i) & 1) == 1 ){
                    tmp[i]++;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < 32; i++){
            if((tmp[i]%3&1) == 1){
                ans += (1<<i);
            }
        }
        return ans;
    }
}
```

