## 串

### [28. 实现 strStr()](https://leetcode.cn/problems/implement-strstr/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 `-1` 。

**说明：**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

**示例 1：**

```
输入：haystack = "hello", needle = "ll"
输出：2
```

**示例 2：**

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

**提示：**

- `1 <= haystack.length, needle.length <= 104`
- `haystack` 和 `needle` 仅由小写英文字符组成

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int k = 0;
        for(int i = 0; i < haystack.length(); i++){
            while(i < haystack.length() && k < needle.length() && haystack.charAt(i) == needle.charAt(k)){
                i++;
                k++;
            }
            if(k == needle.length()){
                return i-k;
            }else{
                i = i-k;
                k=0;
            }
        }
        return -1;
    }
}
```

### [Lc_58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

**示例 2：**

```
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。
```

**示例 3：**

```
输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的“joyboy”。
```

 **提示：**

- `1 <= s.length <= 104`
- `s` 仅有英文字母和空格 `' '` 组成
- `s` 中至少存在一个单词

```java
//从后向前
class Solution {
    public int lengthOfLastWord(String s) {
        int ans = 0;
        for(int i = s.length()-1; i >=0 ; i--){
            while(i >= 0 && s.charAt(i) == ' '){
                i--;
            }
            int tmp = 0;
            while(i >= 0 && s.charAt(i) != ' '){
                tmp++;
                i--;
            }
            if(tmp != 0){
                ans = tmp;
                break;
            }
            
        }
        return ans;
    }
}
```

### [Lc_67. 二进制求和](https://leetcode.cn/problems/add-binary/)

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

**示例 1:**

```
输入: a = "11", b = "1"
输出: "100"
```

**示例 2:**

```
输入: a = "1010", b = "1011"
输出: "10101"
```

**提示：**

- 每个字符串仅由字符 `'0'` 或 `'1'` 组成。
- `1 <= a.length, b.length <= 10^4`
- 字符串如果不是 `"0"` ，就都不含前导零。

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuffer ans = new StringBuffer();

        int n = Math.max(a.length(), b.length()), carry = 0;
        for (int i = 0; i < n; ++i) {
            carry += i < a.length() ? (a.charAt(a.length() - 1 - i) - '0') : 0;
            carry += i < b.length() ? (b.charAt(b.length() - 1 - i) - '0') : 0;
            ans.append((char) (carry % 2 + '0'));
            carry /= 2;
        }

        if (carry > 0) {
            ans.append('1');
        }
        ans.reverse();

        return ans.toString();
    }
}
```

### [Lc_71. 简化路径](https://leetcode.cn/problems/simplify-path/)

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

**示例 1：**

```
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```

**示例 2：**

```
输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
```

**示例 3：**

```
输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```
输入：path = "/a/./b/../../c/"
输出："/c"
```

**提示：**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

```java
//模拟
class Solution {
    public String simplifyPath(String path) {
        Deque<String> deque = new ArrayDeque<>();
        int len = path.length();
        for(int i = 0; i < len; ){
            if(path.charAt(i) == '/'){
                i++;
                continue;
            }
            int j = 1;
            while(i+j < len && path.charAt(i+j) != '/'){
                j++;
            }
            String tmp = path.substring(i,i+j);
            if(tmp.equals("..")){
                if(!deque.isEmpty()){
                    deque.pollLast();
                }
            }else if(!tmp.equals(".")){
                deque.addLast(tmp);
            }
            i = i+j;
        }
        StringBuffer buf = new StringBuffer();
        while(!deque.isEmpty()){
            buf.append("/" + deque.pollFirst());
        }
        return buf.length() == 0 ? "/":buf.toString(); 
    }
}
```

```java
class Solution {
    public String simplifyPath(String path) {
        Deque<String> deque = new ArrayDeque<>();
        String[] tmp = path.split("/");
        for(int i = 0; i < tmp.length; i++){
            if(tmp[i].equals("..")){
                if(!deque.isEmpty()){
                    deque.pollLast();
                }
                //spilt也会存储空串
            }else if(tmp[i].length() > 0 && !tmp[i].equals(".")){
                deque.offerLast(tmp[i]);
            }
        }
        StringBuffer buf = new StringBuffer();
        while(!deque.isEmpty()){
            buf.append("/" + deque.pollFirst());
        }
        return buf.length() == 0 ? "/":buf.toString(); 
    }
}
```

